### This file was generated by Nexus Schema
### Do not make changes to this file directly


input Auth0CreateOneWithoutAuthProviderInput {
  connect: Auth0WhereUniqueInput
  create: Auth0CreateWithoutAuthProviderInput
}

input Auth0CreateWithoutAuthProviderInput {
  createdAt: DateTime
  id: String
  idToken: String
}

input Auth0UpdateOneWithoutAuthProviderInput {
  connect: Auth0WhereUniqueInput
  create: Auth0CreateWithoutAuthProviderInput
  delete: Boolean
  disconnect: Boolean
  update: Auth0UpdateWithoutAuthProviderDataInput
  upsert: Auth0UpsertWithoutAuthProviderInput
}

input Auth0UpdateWithoutAuthProviderDataInput {
  createdAt: DateTime
  id: String
  idToken: String
}

input Auth0UpsertWithoutAuthProviderInput {
  create: Auth0CreateWithoutAuthProviderInput!
  update: Auth0UpdateWithoutAuthProviderDataInput!
}

input Auth0WhereInput {
  AND: [Auth0WhereInput!]
  authProvider: AuthProviderWhereInput
  authProviderId: StringFilter
  createdAt: DateTimeFilter
  id: UUIDFilter
  idToken: NullableStringFilter
  NOT: [Auth0WhereInput!]
  OR: [Auth0WhereInput!]
}

input Auth0WhereUniqueInput {
  id: String
}

input AuthProviderCreateOneWithoutUserInput {
  connect: AuthProviderWhereUniqueInput
  create: AuthProviderCreateWithoutUserInput
}

input AuthProviderCreateWithoutUserInput {
  auth0: Auth0CreateOneWithoutAuthProviderInput
  createdAt: DateTime
  id: String
}

input AuthProviderUpdateOneWithoutUserInput {
  connect: AuthProviderWhereUniqueInput
  create: AuthProviderCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: AuthProviderUpdateWithoutUserDataInput
  upsert: AuthProviderUpsertWithoutUserInput
}

input AuthProviderUpdateWithoutUserDataInput {
  auth0: Auth0UpdateOneWithoutAuthProviderInput
  createdAt: DateTime
  id: String
}

input AuthProviderUpsertWithoutUserInput {
  create: AuthProviderCreateWithoutUserInput!
  update: AuthProviderUpdateWithoutUserDataInput!
}

input AuthProviderWhereInput {
  AND: [AuthProviderWhereInput!]
  auth0: Auth0WhereInput
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [AuthProviderWhereInput!]
  OR: [AuthProviderWhereInput!]
  user: UserWhereInput
  userId: StringFilter
}

input AuthProviderWhereUniqueInput {
  id: String
}

type BatchPayload {
  count: Int!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Buy {
  id: String!
}

input BuyCreateManyWithoutCostInput {
  connect: [BuyWhereUniqueInput!]
  create: [BuyCreateWithoutCostInput!]
}

input BuyCreateManyWithoutPlayerInput {
  connect: [BuyWhereUniqueInput!]
  create: [BuyCreateWithoutPlayerInput!]
}

input BuyCreateWithoutCostInput {
  createdAt: DateTime
  id: String
  player: PlayerCreateOneWithoutBuysInput
  updatedAt: DateTime
}

input BuyCreateWithoutPlayerInput {
  cost: CostCreateOneWithoutBuysInput!
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input BuyFilter {
  every: BuyWhereInput
  none: BuyWhereInput
  some: BuyWhereInput
}

input BuyScalarWhereInput {
  AND: [BuyScalarWhereInput!]
  costId: StringFilter
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [BuyScalarWhereInput!]
  OR: [BuyScalarWhereInput!]
  playerId: NullableStringFilter
  updatedAt: DateTimeFilter
}

input BuyUpdateManyDataInput {
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input BuyUpdateManyWithoutCostInput {
  connect: [BuyWhereUniqueInput!]
  create: [BuyCreateWithoutCostInput!]
  delete: [BuyWhereUniqueInput!]
  deleteMany: [BuyScalarWhereInput!]
  disconnect: [BuyWhereUniqueInput!]
  set: [BuyWhereUniqueInput!]
  update: [BuyUpdateWithWhereUniqueWithoutCostInput!]
  updateMany: [BuyUpdateManyWithWhereNestedInput!]
  upsert: [BuyUpsertWithWhereUniqueWithoutCostInput!]
}

input BuyUpdateManyWithoutPlayerInput {
  connect: [BuyWhereUniqueInput!]
  create: [BuyCreateWithoutPlayerInput!]
  delete: [BuyWhereUniqueInput!]
  deleteMany: [BuyScalarWhereInput!]
  disconnect: [BuyWhereUniqueInput!]
  set: [BuyWhereUniqueInput!]
  update: [BuyUpdateWithWhereUniqueWithoutPlayerInput!]
  updateMany: [BuyUpdateManyWithWhereNestedInput!]
  upsert: [BuyUpsertWithWhereUniqueWithoutPlayerInput!]
}

input BuyUpdateManyWithWhereNestedInput {
  data: BuyUpdateManyDataInput!
  where: BuyScalarWhereInput!
}

input BuyUpdateWithoutCostDataInput {
  createdAt: DateTime
  id: String
  player: PlayerUpdateOneWithoutBuysInput
  updatedAt: DateTime
}

input BuyUpdateWithoutPlayerDataInput {
  cost: CostUpdateOneRequiredWithoutBuysInput
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input BuyUpdateWithWhereUniqueWithoutCostInput {
  data: BuyUpdateWithoutCostDataInput!
  where: BuyWhereUniqueInput!
}

input BuyUpdateWithWhereUniqueWithoutPlayerInput {
  data: BuyUpdateWithoutPlayerDataInput!
  where: BuyWhereUniqueInput!
}

input BuyUpsertWithWhereUniqueWithoutCostInput {
  create: BuyCreateWithoutCostInput!
  update: BuyUpdateWithoutCostDataInput!
  where: BuyWhereUniqueInput!
}

input BuyUpsertWithWhereUniqueWithoutPlayerInput {
  create: BuyCreateWithoutPlayerInput!
  update: BuyUpdateWithoutPlayerDataInput!
  where: BuyWhereUniqueInput!
}

input BuyWhereInput {
  AND: [BuyWhereInput!]
  cost: CostWhereInput
  costId: StringFilter
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [BuyWhereInput!]
  OR: [BuyWhereInput!]
  player: PlayerWhereInput
  playerId: NullableStringFilter
  updatedAt: DateTimeFilter
}

input BuyWhereUniqueInput {
  id: String
}

type Chip {
  color: String!
  denom: Int!
  qtyAvailable: Int
}

input ChipCreateManyWithoutTournamentInput {
  connect: [ChipWhereUniqueInput!]
  create: [ChipCreateWithoutTournamentInput!]
}

input ChipCreateWithoutTournamentInput {
  color: String
  createdAt: DateTime
  denom: Int
  id: String
  qtyAvailable: Int
  rimColor: String
  textColor: String
  updatedAt: DateTime
}

input ChipFilter {
  every: ChipWhereInput
  none: ChipWhereInput
  some: ChipWhereInput
}

input ChipScalarWhereInput {
  AND: [ChipScalarWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  denom: IntFilter
  id: UUIDFilter
  NOT: [ChipScalarWhereInput!]
  OR: [ChipScalarWhereInput!]
  qtyAvailable: NullableIntFilter
  rimColor: NullableStringFilter
  textColor: NullableStringFilter
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input ChipUpdateManyDataInput {
  color: String
  createdAt: DateTime
  denom: Int
  id: String
  qtyAvailable: Int
  rimColor: String
  textColor: String
  updatedAt: DateTime
}

input ChipUpdateManyWithoutTournamentInput {
  connect: [ChipWhereUniqueInput!]
  create: [ChipCreateWithoutTournamentInput!]
  delete: [ChipWhereUniqueInput!]
  deleteMany: [ChipScalarWhereInput!]
  disconnect: [ChipWhereUniqueInput!]
  set: [ChipWhereUniqueInput!]
  update: [ChipUpdateWithWhereUniqueWithoutTournamentInput!]
  updateMany: [ChipUpdateManyWithWhereNestedInput!]
  upsert: [ChipUpsertWithWhereUniqueWithoutTournamentInput!]
}

input ChipUpdateManyWithWhereNestedInput {
  data: ChipUpdateManyDataInput!
  where: ChipScalarWhereInput!
}

input ChipUpdateWithoutTournamentDataInput {
  color: String
  createdAt: DateTime
  denom: Int
  id: String
  qtyAvailable: Int
  rimColor: String
  textColor: String
  updatedAt: DateTime
}

input ChipUpdateWithWhereUniqueWithoutTournamentInput {
  data: ChipUpdateWithoutTournamentDataInput!
  where: ChipWhereUniqueInput!
}

input ChipUpsertWithWhereUniqueWithoutTournamentInput {
  create: ChipCreateWithoutTournamentInput!
  update: ChipUpdateWithoutTournamentDataInput!
  where: ChipWhereUniqueInput!
}

input ChipWhereInput {
  AND: [ChipWhereInput!]
  color: StringFilter
  createdAt: DateTimeFilter
  denom: IntFilter
  id: UUIDFilter
  NOT: [ChipWhereInput!]
  OR: [ChipWhereInput!]
  qtyAvailable: NullableIntFilter
  rimColor: NullableStringFilter
  textColor: NullableStringFilter
  tournament: TournamentWhereInput
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input ChipWhereUniqueInput {
  id: String
}

input ContactCreateemailsInput {
  set: [String!]
}

input ContactCreateManyWithoutUserInput {
  connect: [ContactWhereUniqueInput!]
  create: [ContactCreateWithoutUserInput!]
}

input ContactCreatephonesInput {
  set: [String!]
}

input ContactCreateWithoutUserInput {
  emails: ContactCreateemailsInput
  id: String
  name: String
  phones: ContactCreatephonesInput
}

input ContactFilter {
  every: ContactWhereInput
  none: ContactWhereInput
  some: ContactWhereInput
}

input ContactScalarWhereInput {
  AND: [ContactScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [ContactScalarWhereInput!]
  OR: [ContactScalarWhereInput!]
  userId: StringFilter
}

input ContactUpdateemailsInput {
  set: [String!]
}

input ContactUpdateManyDataInput {
  emails: ContactUpdateemailsInput
  id: String
  name: String
  phones: ContactUpdatephonesInput
}

input ContactUpdateManyWithoutUserInput {
  connect: [ContactWhereUniqueInput!]
  create: [ContactCreateWithoutUserInput!]
  delete: [ContactWhereUniqueInput!]
  deleteMany: [ContactScalarWhereInput!]
  disconnect: [ContactWhereUniqueInput!]
  set: [ContactWhereUniqueInput!]
  update: [ContactUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ContactUpdateManyWithWhereNestedInput!]
  upsert: [ContactUpsertWithWhereUniqueWithoutUserInput!]
}

input ContactUpdateManyWithWhereNestedInput {
  data: ContactUpdateManyDataInput!
  where: ContactScalarWhereInput!
}

input ContactUpdatephonesInput {
  set: [String!]
}

input ContactUpdateWithoutUserDataInput {
  emails: ContactUpdateemailsInput
  id: String
  name: String
  phones: ContactUpdatephonesInput
}

input ContactUpdateWithWhereUniqueWithoutUserInput {
  data: ContactUpdateWithoutUserDataInput!
  where: ContactWhereUniqueInput!
}

input ContactUpsertWithWhereUniqueWithoutUserInput {
  create: ContactCreateWithoutUserInput!
  update: ContactUpdateWithoutUserDataInput!
  where: ContactWhereUniqueInput!
}

input ContactWhereInput {
  AND: [ContactWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  user: UserWhereInput
  userId: StringFilter
}

input ContactWhereUniqueInput {
  id: String
}

type Cost {
  buys(after: BuyWhereUniqueInput, before: BuyWhereUniqueInput, first: Int, last: Int): [Buy!]!
  chipStack: Int!
  costType: CostType!
  price: Int!
}

input CostCreateManyWithoutTournamentInput {
  connect: [CostWhereUniqueInput!]
  create: [CostCreateWithoutTournamentInput!]
}

input CostCreateOneWithoutBuysInput {
  connect: CostWhereUniqueInput
  create: CostCreateWithoutBuysInput
}

input CostCreateWithoutBuysInput {
  chipStack: Int
  costType: CostType
  createdAt: DateTime
  id: String
  price: Int
  tournament: TournamentCreateOneWithoutCostsInput!
  updatedAt: DateTime
}

input CostCreateWithoutTournamentInput {
  buys: BuyCreateManyWithoutCostInput
  chipStack: Int
  costType: CostType
  createdAt: DateTime
  id: String
  price: Int
  updatedAt: DateTime
}

input CostFilter {
  every: CostWhereInput
  none: CostWhereInput
  some: CostWhereInput
}

input CostScalarWhereInput {
  AND: [CostScalarWhereInput!]
  buys: BuyFilter
  chipStack: IntFilter
  costType: CostType
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [CostScalarWhereInput!]
  OR: [CostScalarWhereInput!]
  price: IntFilter
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

enum CostType {
  Addon
  Bounty
  Buyin
  Charity
  House
  Rebuy
}

input CostUpdateManyDataInput {
  chipStack: Int
  costType: CostType
  createdAt: DateTime
  id: String
  price: Int
  updatedAt: DateTime
}

input CostUpdateManyWithoutTournamentInput {
  connect: [CostWhereUniqueInput!]
  create: [CostCreateWithoutTournamentInput!]
  delete: [CostWhereUniqueInput!]
  deleteMany: [CostScalarWhereInput!]
  disconnect: [CostWhereUniqueInput!]
  set: [CostWhereUniqueInput!]
  update: [CostUpdateWithWhereUniqueWithoutTournamentInput!]
  updateMany: [CostUpdateManyWithWhereNestedInput!]
  upsert: [CostUpsertWithWhereUniqueWithoutTournamentInput!]
}

input CostUpdateManyWithWhereNestedInput {
  data: CostUpdateManyDataInput!
  where: CostScalarWhereInput!
}

input CostUpdateOneRequiredWithoutBuysInput {
  connect: CostWhereUniqueInput
  create: CostCreateWithoutBuysInput
  update: CostUpdateWithoutBuysDataInput
  upsert: CostUpsertWithoutBuysInput
}

input CostUpdateWithoutBuysDataInput {
  chipStack: Int
  costType: CostType
  createdAt: DateTime
  id: String
  price: Int
  tournament: TournamentUpdateOneRequiredWithoutCostsInput
  updatedAt: DateTime
}

input CostUpdateWithoutTournamentDataInput {
  buys: BuyUpdateManyWithoutCostInput
  chipStack: Int
  costType: CostType
  createdAt: DateTime
  id: String
  price: Int
  updatedAt: DateTime
}

input CostUpdateWithWhereUniqueWithoutTournamentInput {
  data: CostUpdateWithoutTournamentDataInput!
  where: CostWhereUniqueInput!
}

input CostUpsertWithoutBuysInput {
  create: CostCreateWithoutBuysInput!
  update: CostUpdateWithoutBuysDataInput!
}

input CostUpsertWithWhereUniqueWithoutTournamentInput {
  create: CostCreateWithoutTournamentInput!
  update: CostUpdateWithoutTournamentDataInput!
  where: CostWhereUniqueInput!
}

input CostWhereInput {
  AND: [CostWhereInput!]
  buys: BuyFilter
  chipStack: IntFilter
  costType: CostType
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [CostWhereInput!]
  OR: [CostWhereInput!]
  price: IntFilter
  tournament: TournamentWhereInput
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input CostWhereUniqueInput {
  id: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

enum Game {
  CAP
  HORSE
  HOSE
  L7S
  LHE
  NLHE
  PLO
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createOneUser(data: UserCreateInput!): User!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input PayoutLevelCreateManyWithoutTournamentInput {
  connect: [PayoutLevelWhereUniqueInput!]
  create: [PayoutLevelCreateWithoutTournamentInput!]
}

input PayoutLevelCreateWithoutTournamentInput {
  createdAt: DateTime
  id: String
  levelNumber: Int!
  payCount: Int!
  playerCount: Int!
  updatedAt: DateTime
}

input PayoutLevelFilter {
  every: PayoutLevelWhereInput
  none: PayoutLevelWhereInput
  some: PayoutLevelWhereInput
}

input PayoutLevelScalarWhereInput {
  AND: [PayoutLevelScalarWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  levelNumber: IntFilter
  NOT: [PayoutLevelScalarWhereInput!]
  OR: [PayoutLevelScalarWhereInput!]
  payCount: IntFilter
  playerCount: IntFilter
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input PayoutLevelUpdateManyDataInput {
  createdAt: DateTime
  id: String
  levelNumber: Int
  payCount: Int
  playerCount: Int
  updatedAt: DateTime
}

input PayoutLevelUpdateManyWithoutTournamentInput {
  connect: [PayoutLevelWhereUniqueInput!]
  create: [PayoutLevelCreateWithoutTournamentInput!]
  delete: [PayoutLevelWhereUniqueInput!]
  deleteMany: [PayoutLevelScalarWhereInput!]
  disconnect: [PayoutLevelWhereUniqueInput!]
  set: [PayoutLevelWhereUniqueInput!]
  update: [PayoutLevelUpdateWithWhereUniqueWithoutTournamentInput!]
  updateMany: [PayoutLevelUpdateManyWithWhereNestedInput!]
  upsert: [PayoutLevelUpsertWithWhereUniqueWithoutTournamentInput!]
}

input PayoutLevelUpdateManyWithWhereNestedInput {
  data: PayoutLevelUpdateManyDataInput!
  where: PayoutLevelScalarWhereInput!
}

input PayoutLevelUpdateWithoutTournamentDataInput {
  createdAt: DateTime
  id: String
  levelNumber: Int
  payCount: Int
  playerCount: Int
  updatedAt: DateTime
}

input PayoutLevelUpdateWithWhereUniqueWithoutTournamentInput {
  data: PayoutLevelUpdateWithoutTournamentDataInput!
  where: PayoutLevelWhereUniqueInput!
}

input PayoutLevelUpsertWithWhereUniqueWithoutTournamentInput {
  create: PayoutLevelCreateWithoutTournamentInput!
  update: PayoutLevelUpdateWithoutTournamentDataInput!
  where: PayoutLevelWhereUniqueInput!
}

input PayoutLevelWhereInput {
  AND: [PayoutLevelWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  levelNumber: IntFilter
  NOT: [PayoutLevelWhereInput!]
  OR: [PayoutLevelWhereInput!]
  payCount: IntFilter
  playerCount: IntFilter
  tournament: TournamentWhereInput
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input PayoutLevelWhereUniqueInput {
  id: String
}

input PlayerCreateManyWithoutUserInput {
  connect: [PlayerWhereUniqueInput!]
  create: [PlayerCreateWithoutUserInput!]
}

input PlayerCreateOneWithoutBuysInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateWithoutBuysInput
}

input PlayerCreateOneWithoutSeatInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateWithoutSeatInput
}

input PlayerCreateOneWithoutTournamentsInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateWithoutTournamentsInput
}

input PlayerCreateWithoutBuysInput {
  createdAt: DateTime
  id: String
  name: String
  seat: SeatCreateOneWithoutPlayerInput
  tournaments: TournamentCreateManyWithoutPlayerInput
  updatedAt: DateTime
  user: UserCreateOneWithoutPlayersInput!
}

input PlayerCreateWithoutSeatInput {
  buys: BuyCreateManyWithoutPlayerInput
  createdAt: DateTime
  id: String
  name: String
  tournaments: TournamentCreateManyWithoutPlayerInput
  updatedAt: DateTime
  user: UserCreateOneWithoutPlayersInput!
}

input PlayerCreateWithoutTournamentsInput {
  buys: BuyCreateManyWithoutPlayerInput
  createdAt: DateTime
  id: String
  name: String
  seat: SeatCreateOneWithoutPlayerInput
  updatedAt: DateTime
  user: UserCreateOneWithoutPlayersInput!
}

input PlayerCreateWithoutUserInput {
  buys: BuyCreateManyWithoutPlayerInput
  createdAt: DateTime
  id: String
  name: String
  seat: SeatCreateOneWithoutPlayerInput
  tournaments: TournamentCreateManyWithoutPlayerInput
  updatedAt: DateTime
}

input PlayerFilter {
  every: PlayerWhereInput
  none: PlayerWhereInput
  some: PlayerWhereInput
}

input PlayerScalarWhereInput {
  AND: [PlayerScalarWhereInput!]
  buys: BuyFilter
  createdAt: DateTimeFilter
  id: UUIDFilter
  name: NullableStringFilter
  NOT: [PlayerScalarWhereInput!]
  OR: [PlayerScalarWhereInput!]
  tournaments: TournamentFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input PlayerUpdateManyDataInput {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input PlayerUpdateManyWithoutUserInput {
  connect: [PlayerWhereUniqueInput!]
  create: [PlayerCreateWithoutUserInput!]
  delete: [PlayerWhereUniqueInput!]
  deleteMany: [PlayerScalarWhereInput!]
  disconnect: [PlayerWhereUniqueInput!]
  set: [PlayerWhereUniqueInput!]
  update: [PlayerUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PlayerUpdateManyWithWhereNestedInput!]
  upsert: [PlayerUpsertWithWhereUniqueWithoutUserInput!]
}

input PlayerUpdateManyWithWhereNestedInput {
  data: PlayerUpdateManyDataInput!
  where: PlayerScalarWhereInput!
}

input PlayerUpdateOneRequiredWithoutSeatInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateWithoutSeatInput
  update: PlayerUpdateWithoutSeatDataInput
  upsert: PlayerUpsertWithoutSeatInput
}

input PlayerUpdateOneWithoutBuysInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateWithoutBuysInput
  delete: Boolean
  disconnect: Boolean
  update: PlayerUpdateWithoutBuysDataInput
  upsert: PlayerUpsertWithoutBuysInput
}

input PlayerUpdateOneWithoutTournamentsInput {
  connect: PlayerWhereUniqueInput
  create: PlayerCreateWithoutTournamentsInput
  delete: Boolean
  disconnect: Boolean
  update: PlayerUpdateWithoutTournamentsDataInput
  upsert: PlayerUpsertWithoutTournamentsInput
}

input PlayerUpdateWithoutBuysDataInput {
  createdAt: DateTime
  id: String
  name: String
  seat: SeatUpdateOneWithoutPlayerInput
  tournaments: TournamentUpdateManyWithoutPlayerInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPlayersInput
}

input PlayerUpdateWithoutSeatDataInput {
  buys: BuyUpdateManyWithoutPlayerInput
  createdAt: DateTime
  id: String
  name: String
  tournaments: TournamentUpdateManyWithoutPlayerInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPlayersInput
}

input PlayerUpdateWithoutTournamentsDataInput {
  buys: BuyUpdateManyWithoutPlayerInput
  createdAt: DateTime
  id: String
  name: String
  seat: SeatUpdateOneWithoutPlayerInput
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutPlayersInput
}

input PlayerUpdateWithoutUserDataInput {
  buys: BuyUpdateManyWithoutPlayerInput
  createdAt: DateTime
  id: String
  name: String
  seat: SeatUpdateOneWithoutPlayerInput
  tournaments: TournamentUpdateManyWithoutPlayerInput
  updatedAt: DateTime
}

input PlayerUpdateWithWhereUniqueWithoutUserInput {
  data: PlayerUpdateWithoutUserDataInput!
  where: PlayerWhereUniqueInput!
}

input PlayerUpsertWithoutBuysInput {
  create: PlayerCreateWithoutBuysInput!
  update: PlayerUpdateWithoutBuysDataInput!
}

input PlayerUpsertWithoutSeatInput {
  create: PlayerCreateWithoutSeatInput!
  update: PlayerUpdateWithoutSeatDataInput!
}

input PlayerUpsertWithoutTournamentsInput {
  create: PlayerCreateWithoutTournamentsInput!
  update: PlayerUpdateWithoutTournamentsDataInput!
}

input PlayerUpsertWithWhereUniqueWithoutUserInput {
  create: PlayerCreateWithoutUserInput!
  update: PlayerUpdateWithoutUserDataInput!
  where: PlayerWhereUniqueInput!
}

input PlayerWhereInput {
  AND: [PlayerWhereInput!]
  buys: BuyFilter
  createdAt: DateTimeFilter
  id: UUIDFilter
  name: NullableStringFilter
  NOT: [PlayerWhereInput!]
  OR: [PlayerWhereInput!]
  seat: SeatWhereInput
  tournaments: TournamentFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input PlayerWhereUniqueInput {
  id: String
}

type Query {
  allUsers: [User!]
  tournament(where: TournamentWhereUniqueInput!): Tournament
  tournaments(after: TournamentWhereUniqueInput, before: TournamentWhereUniqueInput, first: Int, last: Int): [Tournament!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input SeatCreateManyWithoutTableInput {
  connect: [SeatWhereUniqueInput!]
  create: [SeatCreateWithoutTableInput!]
}

input SeatCreateOneWithoutPlayerInput {
  connect: SeatWhereUniqueInput
  create: SeatCreateWithoutPlayerInput
}

input SeatCreateWithoutPlayerInput {
  createdAt: DateTime
  id: String
  number: Int
  table: TableCreateOneWithoutSeatsInput!
  updatedAt: DateTime
}

input SeatCreateWithoutTableInput {
  createdAt: DateTime
  id: String
  number: Int
  player: PlayerCreateOneWithoutSeatInput!
  updatedAt: DateTime
}

input SeatFilter {
  every: SeatWhereInput
  none: SeatWhereInput
  some: SeatWhereInput
}

input SeatScalarWhereInput {
  AND: [SeatScalarWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [SeatScalarWhereInput!]
  number: IntFilter
  OR: [SeatScalarWhereInput!]
  playerId: StringFilter
  tableId: StringFilter
  updatedAt: DateTimeFilter
}

input SeatUpdateManyDataInput {
  createdAt: DateTime
  id: String
  number: Int
  updatedAt: DateTime
}

input SeatUpdateManyWithoutTableInput {
  connect: [SeatWhereUniqueInput!]
  create: [SeatCreateWithoutTableInput!]
  delete: [SeatWhereUniqueInput!]
  deleteMany: [SeatScalarWhereInput!]
  disconnect: [SeatWhereUniqueInput!]
  set: [SeatWhereUniqueInput!]
  update: [SeatUpdateWithWhereUniqueWithoutTableInput!]
  updateMany: [SeatUpdateManyWithWhereNestedInput!]
  upsert: [SeatUpsertWithWhereUniqueWithoutTableInput!]
}

input SeatUpdateManyWithWhereNestedInput {
  data: SeatUpdateManyDataInput!
  where: SeatScalarWhereInput!
}

input SeatUpdateOneWithoutPlayerInput {
  connect: SeatWhereUniqueInput
  create: SeatCreateWithoutPlayerInput
  delete: Boolean
  disconnect: Boolean
  update: SeatUpdateWithoutPlayerDataInput
  upsert: SeatUpsertWithoutPlayerInput
}

input SeatUpdateWithoutPlayerDataInput {
  createdAt: DateTime
  id: String
  number: Int
  table: TableUpdateOneRequiredWithoutSeatsInput
  updatedAt: DateTime
}

input SeatUpdateWithoutTableDataInput {
  createdAt: DateTime
  id: String
  number: Int
  player: PlayerUpdateOneRequiredWithoutSeatInput
  updatedAt: DateTime
}

input SeatUpdateWithWhereUniqueWithoutTableInput {
  data: SeatUpdateWithoutTableDataInput!
  where: SeatWhereUniqueInput!
}

input SeatUpsertWithoutPlayerInput {
  create: SeatCreateWithoutPlayerInput!
  update: SeatUpdateWithoutPlayerDataInput!
}

input SeatUpsertWithWhereUniqueWithoutTableInput {
  create: SeatCreateWithoutTableInput!
  update: SeatUpdateWithoutTableDataInput!
  where: SeatWhereUniqueInput!
}

input SeatWhereInput {
  AND: [SeatWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [SeatWhereInput!]
  number: IntFilter
  OR: [SeatWhereInput!]
  player: PlayerWhereInput
  playerId: StringFilter
  table: TableWhereInput
  tableId: StringFilter
  updatedAt: DateTimeFilter
}

input SeatWhereUniqueInput {
  id: String
}

type Segment {
  ante: Int
  bBlind: Int
  duration: Int!
  game: Game!
  sBlind: Int
}

input SegmentCreateManyWithoutTournamentInput {
  connect: [SegmentWhereUniqueInput!]
  create: [SegmentCreateWithoutTournamentInput!]
}

input SegmentCreateWithoutTournamentInput {
  ante: Int
  bBlind: Int
  createdAt: DateTime
  duration: Int
  game: Game
  id: String
  sBlind: Int
  updatedAt: DateTime
}

input SegmentFilter {
  every: SegmentWhereInput
  none: SegmentWhereInput
  some: SegmentWhereInput
}

input SegmentScalarWhereInput {
  AND: [SegmentScalarWhereInput!]
  ante: NullableIntFilter
  bBlind: NullableIntFilter
  createdAt: DateTimeFilter
  duration: IntFilter
  game: Game
  id: UUIDFilter
  NOT: [SegmentScalarWhereInput!]
  OR: [SegmentScalarWhereInput!]
  sBlind: NullableIntFilter
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input SegmentUpdateManyDataInput {
  ante: Int
  bBlind: Int
  createdAt: DateTime
  duration: Int
  game: Game
  id: String
  sBlind: Int
  updatedAt: DateTime
}

input SegmentUpdateManyWithoutTournamentInput {
  connect: [SegmentWhereUniqueInput!]
  create: [SegmentCreateWithoutTournamentInput!]
  delete: [SegmentWhereUniqueInput!]
  deleteMany: [SegmentScalarWhereInput!]
  disconnect: [SegmentWhereUniqueInput!]
  set: [SegmentWhereUniqueInput!]
  update: [SegmentUpdateWithWhereUniqueWithoutTournamentInput!]
  updateMany: [SegmentUpdateManyWithWhereNestedInput!]
  upsert: [SegmentUpsertWithWhereUniqueWithoutTournamentInput!]
}

input SegmentUpdateManyWithWhereNestedInput {
  data: SegmentUpdateManyDataInput!
  where: SegmentScalarWhereInput!
}

input SegmentUpdateWithoutTournamentDataInput {
  ante: Int
  bBlind: Int
  createdAt: DateTime
  duration: Int
  game: Game
  id: String
  sBlind: Int
  updatedAt: DateTime
}

input SegmentUpdateWithWhereUniqueWithoutTournamentInput {
  data: SegmentUpdateWithoutTournamentDataInput!
  where: SegmentWhereUniqueInput!
}

input SegmentUpsertWithWhereUniqueWithoutTournamentInput {
  create: SegmentCreateWithoutTournamentInput!
  update: SegmentUpdateWithoutTournamentDataInput!
  where: SegmentWhereUniqueInput!
}

input SegmentWhereInput {
  AND: [SegmentWhereInput!]
  ante: NullableIntFilter
  bBlind: NullableIntFilter
  createdAt: DateTimeFilter
  duration: IntFilter
  game: Game
  id: UUIDFilter
  NOT: [SegmentWhereInput!]
  OR: [SegmentWhereInput!]
  sBlind: NullableIntFilter
  tournament: TournamentWhereInput
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input SegmentWhereUniqueInput {
  id: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Table {
  name: String!
}

input TableCreateManyWithoutTournamentInput {
  connect: [TableWhereUniqueInput!]
  create: [TableCreateWithoutTournamentInput!]
}

input TableCreateOneWithoutSeatsInput {
  connect: TableWhereUniqueInput
  create: TableCreateWithoutSeatsInput
}

input TableCreateWithoutSeatsInput {
  createdAt: DateTime
  id: String
  name: String
  tournament: TournamentCreateOneWithoutTablesInput!
  updatedAt: DateTime
}

input TableCreateWithoutTournamentInput {
  createdAt: DateTime
  id: String
  name: String
  seats: SeatCreateManyWithoutTableInput
  updatedAt: DateTime
}

input TableFilter {
  every: TableWhereInput
  none: TableWhereInput
  some: TableWhereInput
}

input TableScalarWhereInput {
  AND: [TableScalarWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [TableScalarWhereInput!]
  OR: [TableScalarWhereInput!]
  seats: SeatFilter
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input TableUpdateManyDataInput {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input TableUpdateManyWithoutTournamentInput {
  connect: [TableWhereUniqueInput!]
  create: [TableCreateWithoutTournamentInput!]
  delete: [TableWhereUniqueInput!]
  deleteMany: [TableScalarWhereInput!]
  disconnect: [TableWhereUniqueInput!]
  set: [TableWhereUniqueInput!]
  update: [TableUpdateWithWhereUniqueWithoutTournamentInput!]
  updateMany: [TableUpdateManyWithWhereNestedInput!]
  upsert: [TableUpsertWithWhereUniqueWithoutTournamentInput!]
}

input TableUpdateManyWithWhereNestedInput {
  data: TableUpdateManyDataInput!
  where: TableScalarWhereInput!
}

input TableUpdateOneRequiredWithoutSeatsInput {
  connect: TableWhereUniqueInput
  create: TableCreateWithoutSeatsInput
  update: TableUpdateWithoutSeatsDataInput
  upsert: TableUpsertWithoutSeatsInput
}

input TableUpdateWithoutSeatsDataInput {
  createdAt: DateTime
  id: String
  name: String
  tournament: TournamentUpdateOneRequiredWithoutTablesInput
  updatedAt: DateTime
}

input TableUpdateWithoutTournamentDataInput {
  createdAt: DateTime
  id: String
  name: String
  seats: SeatUpdateManyWithoutTableInput
  updatedAt: DateTime
}

input TableUpdateWithWhereUniqueWithoutTournamentInput {
  data: TableUpdateWithoutTournamentDataInput!
  where: TableWhereUniqueInput!
}

input TableUpsertWithoutSeatsInput {
  create: TableCreateWithoutSeatsInput!
  update: TableUpdateWithoutSeatsDataInput!
}

input TableUpsertWithWhereUniqueWithoutTournamentInput {
  create: TableCreateWithoutTournamentInput!
  update: TableUpdateWithoutTournamentDataInput!
  where: TableWhereUniqueInput!
}

input TableWhereInput {
  AND: [TableWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [TableWhereInput!]
  OR: [TableWhereInput!]
  seats: SeatFilter
  tournament: TournamentWhereInput
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input TableWhereUniqueInput {
  id: String
}

type Tag {
  name: String!
}

input TagCreateManyWithoutTournamentInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutTournamentInput!]
}

input TagCreateWithoutTournamentInput {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input TagFilter {
  every: TagWhereInput
  none: TagWhereInput
  some: TagWhereInput
}

input TagScalarWhereInput {
  AND: [TagScalarWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input TagUpdateManyDataInput {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input TagUpdateManyWithoutTournamentInput {
  connect: [TagWhereUniqueInput!]
  create: [TagCreateWithoutTournamentInput!]
  delete: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutTournamentInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutTournamentInput!]
}

input TagUpdateManyWithWhereNestedInput {
  data: TagUpdateManyDataInput!
  where: TagScalarWhereInput!
}

input TagUpdateWithoutTournamentDataInput {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input TagUpdateWithWhereUniqueWithoutTournamentInput {
  data: TagUpdateWithoutTournamentDataInput!
  where: TagWhereUniqueInput!
}

input TagUpsertWithWhereUniqueWithoutTournamentInput {
  create: TagCreateWithoutTournamentInput!
  update: TagUpdateWithoutTournamentDataInput!
  where: TagWhereUniqueInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  tournament: TournamentWhereInput
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input TagWhereUniqueInput {
  id: String
}

type Timer {
  active: Boolean!
  elapsed: Int!
  endOfRoundSpeech: String
  updatedAt: DateTime!
}

input TimerCreateOneWithoutTournamentInput {
  connect: TimerWhereUniqueInput
  create: TimerCreateWithoutTournamentInput
}

input TimerCreateWithoutTournamentInput {
  active: Boolean
  backgroundColor: String
  createdAt: DateTime
  elapsed: Int
  endOfRoundSpeech: String
  id: String
  oneMinuteRemainingSpeech: String
  playEndOfRoundSound: Boolean
  playOneMinuteRemainingSound: Boolean
  updatedAt: DateTime
}

input TimerUpdateOneWithoutTournamentInput {
  connect: TimerWhereUniqueInput
  create: TimerCreateWithoutTournamentInput
  delete: Boolean
  disconnect: Boolean
  update: TimerUpdateWithoutTournamentDataInput
  upsert: TimerUpsertWithoutTournamentInput
}

input TimerUpdateWithoutTournamentDataInput {
  active: Boolean
  backgroundColor: String
  createdAt: DateTime
  elapsed: Int
  endOfRoundSpeech: String
  id: String
  oneMinuteRemainingSpeech: String
  playEndOfRoundSound: Boolean
  playOneMinuteRemainingSound: Boolean
  updatedAt: DateTime
}

input TimerUpsertWithoutTournamentInput {
  create: TimerCreateWithoutTournamentInput!
  update: TimerUpdateWithoutTournamentDataInput!
}

input TimerWhereInput {
  active: BooleanFilter
  AND: [TimerWhereInput!]
  backgroundColor: NullableStringFilter
  createdAt: DateTimeFilter
  elapsed: IntFilter
  endOfRoundSpeech: NullableStringFilter
  id: UUIDFilter
  NOT: [TimerWhereInput!]
  oneMinuteRemainingSpeech: NullableStringFilter
  OR: [TimerWhereInput!]
  playEndOfRoundSound: BooleanFilter
  playOneMinuteRemainingSound: BooleanFilter
  tournament: TournamentWhereInput
  tournamentId: StringFilter
  updatedAt: DateTimeFilter
}

input TimerWhereUniqueInput {
  id: String
}

type Tournament {
  chips(after: ChipWhereUniqueInput, before: ChipWhereUniqueInput, first: Int, last: Int): [Chip!]!
  comments: String
  costs(after: CostWhereUniqueInput, before: CostWhereUniqueInput, first: Int, last: Int): [Cost!]!
  game: Game!
  id: String!
  segments(after: SegmentWhereUniqueInput, before: SegmentWhereUniqueInput, first: Int, last: Int): [Segment!]!
  subtitle: String
  tags(after: TagWhereUniqueInput, before: TagWhereUniqueInput, first: Int, last: Int): [Tag!]!
  timer: Timer
  title: String!
  userId: String
}

input TournamentCreateManyWithoutPlayerInput {
  connect: [TournamentWhereUniqueInput!]
  create: [TournamentCreateWithoutPlayerInput!]
}

input TournamentCreateManyWithoutUserInput {
  connect: [TournamentWhereUniqueInput!]
  create: [TournamentCreateWithoutUserInput!]
}

input TournamentCreateOneWithoutCostsInput {
  connect: TournamentWhereUniqueInput
  create: TournamentCreateWithoutCostsInput
}

input TournamentCreateOneWithoutTablesInput {
  connect: TournamentWhereUniqueInput
  create: TournamentCreateWithoutTablesInput
}

input TournamentCreateWithoutCostsInput {
  childrenUpdatedAt: DateTime
  chips: ChipCreateManyWithoutTournamentInput
  comments: String
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelCreateManyWithoutTournamentInput
  Player: PlayerCreateOneWithoutTournamentsInput
  segments: SegmentCreateManyWithoutTournamentInput
  subtitle: String
  tables: TableCreateManyWithoutTournamentInput
  tags: TagCreateManyWithoutTournamentInput
  timer: TimerCreateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
  User: UserCreateOneWithoutTournamentsInput
}

input TournamentCreateWithoutPlayerInput {
  childrenUpdatedAt: DateTime
  chips: ChipCreateManyWithoutTournamentInput
  comments: String
  costs: CostCreateManyWithoutTournamentInput
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelCreateManyWithoutTournamentInput
  segments: SegmentCreateManyWithoutTournamentInput
  subtitle: String
  tables: TableCreateManyWithoutTournamentInput
  tags: TagCreateManyWithoutTournamentInput
  timer: TimerCreateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
  User: UserCreateOneWithoutTournamentsInput
}

input TournamentCreateWithoutTablesInput {
  childrenUpdatedAt: DateTime
  chips: ChipCreateManyWithoutTournamentInput
  comments: String
  costs: CostCreateManyWithoutTournamentInput
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelCreateManyWithoutTournamentInput
  Player: PlayerCreateOneWithoutTournamentsInput
  segments: SegmentCreateManyWithoutTournamentInput
  subtitle: String
  tags: TagCreateManyWithoutTournamentInput
  timer: TimerCreateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
  User: UserCreateOneWithoutTournamentsInput
}

input TournamentCreateWithoutUserInput {
  childrenUpdatedAt: DateTime
  chips: ChipCreateManyWithoutTournamentInput
  comments: String
  costs: CostCreateManyWithoutTournamentInput
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelCreateManyWithoutTournamentInput
  Player: PlayerCreateOneWithoutTournamentsInput
  segments: SegmentCreateManyWithoutTournamentInput
  subtitle: String
  tables: TableCreateManyWithoutTournamentInput
  tags: TagCreateManyWithoutTournamentInput
  timer: TimerCreateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
}

input TournamentFilter {
  every: TournamentWhereInput
  none: TournamentWhereInput
  some: TournamentWhereInput
}

input TournamentScalarWhereInput {
  AND: [TournamentScalarWhereInput!]
  childrenUpdatedAt: NullableDateTimeFilter
  chips: ChipFilter
  comments: NullableStringFilter
  costs: CostFilter
  createdAt: DateTimeFilter
  game: Game
  id: UUIDFilter
  NOT: [TournamentScalarWhereInput!]
  OR: [TournamentScalarWhereInput!]
  payoutLevels: PayoutLevelFilter
  playerId: NullableStringFilter
  segments: SegmentFilter
  subtitle: NullableStringFilter
  tables: TableFilter
  tags: TagFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: NullableStringFilter
}

input TournamentUpdateManyDataInput {
  childrenUpdatedAt: DateTime
  comments: String
  createdAt: DateTime
  game: Game
  id: String
  subtitle: String
  title: String
  updatedAt: DateTime
}

input TournamentUpdateManyWithoutPlayerInput {
  connect: [TournamentWhereUniqueInput!]
  create: [TournamentCreateWithoutPlayerInput!]
  delete: [TournamentWhereUniqueInput!]
  deleteMany: [TournamentScalarWhereInput!]
  disconnect: [TournamentWhereUniqueInput!]
  set: [TournamentWhereUniqueInput!]
  update: [TournamentUpdateWithWhereUniqueWithoutPlayerInput!]
  updateMany: [TournamentUpdateManyWithWhereNestedInput!]
  upsert: [TournamentUpsertWithWhereUniqueWithoutPlayerInput!]
}

input TournamentUpdateManyWithoutUserInput {
  connect: [TournamentWhereUniqueInput!]
  create: [TournamentCreateWithoutUserInput!]
  delete: [TournamentWhereUniqueInput!]
  deleteMany: [TournamentScalarWhereInput!]
  disconnect: [TournamentWhereUniqueInput!]
  set: [TournamentWhereUniqueInput!]
  update: [TournamentUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TournamentUpdateManyWithWhereNestedInput!]
  upsert: [TournamentUpsertWithWhereUniqueWithoutUserInput!]
}

input TournamentUpdateManyWithWhereNestedInput {
  data: TournamentUpdateManyDataInput!
  where: TournamentScalarWhereInput!
}

input TournamentUpdateOneRequiredWithoutCostsInput {
  connect: TournamentWhereUniqueInput
  create: TournamentCreateWithoutCostsInput
  update: TournamentUpdateWithoutCostsDataInput
  upsert: TournamentUpsertWithoutCostsInput
}

input TournamentUpdateOneRequiredWithoutTablesInput {
  connect: TournamentWhereUniqueInput
  create: TournamentCreateWithoutTablesInput
  update: TournamentUpdateWithoutTablesDataInput
  upsert: TournamentUpsertWithoutTablesInput
}

input TournamentUpdateWithoutCostsDataInput {
  childrenUpdatedAt: DateTime
  chips: ChipUpdateManyWithoutTournamentInput
  comments: String
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelUpdateManyWithoutTournamentInput
  Player: PlayerUpdateOneWithoutTournamentsInput
  segments: SegmentUpdateManyWithoutTournamentInput
  subtitle: String
  tables: TableUpdateManyWithoutTournamentInput
  tags: TagUpdateManyWithoutTournamentInput
  timer: TimerUpdateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
  User: UserUpdateOneWithoutTournamentsInput
}

input TournamentUpdateWithoutPlayerDataInput {
  childrenUpdatedAt: DateTime
  chips: ChipUpdateManyWithoutTournamentInput
  comments: String
  costs: CostUpdateManyWithoutTournamentInput
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelUpdateManyWithoutTournamentInput
  segments: SegmentUpdateManyWithoutTournamentInput
  subtitle: String
  tables: TableUpdateManyWithoutTournamentInput
  tags: TagUpdateManyWithoutTournamentInput
  timer: TimerUpdateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
  User: UserUpdateOneWithoutTournamentsInput
}

input TournamentUpdateWithoutTablesDataInput {
  childrenUpdatedAt: DateTime
  chips: ChipUpdateManyWithoutTournamentInput
  comments: String
  costs: CostUpdateManyWithoutTournamentInput
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelUpdateManyWithoutTournamentInput
  Player: PlayerUpdateOneWithoutTournamentsInput
  segments: SegmentUpdateManyWithoutTournamentInput
  subtitle: String
  tags: TagUpdateManyWithoutTournamentInput
  timer: TimerUpdateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
  User: UserUpdateOneWithoutTournamentsInput
}

input TournamentUpdateWithoutUserDataInput {
  childrenUpdatedAt: DateTime
  chips: ChipUpdateManyWithoutTournamentInput
  comments: String
  costs: CostUpdateManyWithoutTournamentInput
  createdAt: DateTime
  game: Game
  id: String
  payoutLevels: PayoutLevelUpdateManyWithoutTournamentInput
  Player: PlayerUpdateOneWithoutTournamentsInput
  segments: SegmentUpdateManyWithoutTournamentInput
  subtitle: String
  tables: TableUpdateManyWithoutTournamentInput
  tags: TagUpdateManyWithoutTournamentInput
  timer: TimerUpdateOneWithoutTournamentInput
  title: String
  updatedAt: DateTime
}

input TournamentUpdateWithWhereUniqueWithoutPlayerInput {
  data: TournamentUpdateWithoutPlayerDataInput!
  where: TournamentWhereUniqueInput!
}

input TournamentUpdateWithWhereUniqueWithoutUserInput {
  data: TournamentUpdateWithoutUserDataInput!
  where: TournamentWhereUniqueInput!
}

input TournamentUpsertWithoutCostsInput {
  create: TournamentCreateWithoutCostsInput!
  update: TournamentUpdateWithoutCostsDataInput!
}

input TournamentUpsertWithoutTablesInput {
  create: TournamentCreateWithoutTablesInput!
  update: TournamentUpdateWithoutTablesDataInput!
}

input TournamentUpsertWithWhereUniqueWithoutPlayerInput {
  create: TournamentCreateWithoutPlayerInput!
  update: TournamentUpdateWithoutPlayerDataInput!
  where: TournamentWhereUniqueInput!
}

input TournamentUpsertWithWhereUniqueWithoutUserInput {
  create: TournamentCreateWithoutUserInput!
  update: TournamentUpdateWithoutUserDataInput!
  where: TournamentWhereUniqueInput!
}

input TournamentWhereInput {
  AND: [TournamentWhereInput!]
  childrenUpdatedAt: NullableDateTimeFilter
  chips: ChipFilter
  comments: NullableStringFilter
  costs: CostFilter
  createdAt: DateTimeFilter
  game: Game
  id: UUIDFilter
  NOT: [TournamentWhereInput!]
  OR: [TournamentWhereInput!]
  payoutLevels: PayoutLevelFilter
  Player: PlayerWhereInput
  playerId: NullableStringFilter
  segments: SegmentFilter
  subtitle: NullableStringFilter
  tables: TableFilter
  tags: TagFilter
  timer: TimerWhereInput
  title: StringFilter
  updatedAt: DateTimeFilter
  User: UserWhereInput
  userId: NullableStringFilter
}

input TournamentWhereUniqueInput {
  id: String
}

type User {
  id: String!
  name: String!
  tournaments(after: TournamentWhereUniqueInput, before: TournamentWhereUniqueInput, first: Int, last: Int): [Tournament!]!
}

input UserCreateInput {
  authProvider: AuthProviderCreateOneWithoutUserInput
  contacts: ContactCreateManyWithoutUserInput
  createdAt: DateTime
  credits: Int
  id: String
  name: String
  players: PlayerCreateManyWithoutUserInput
  tournaments: TournamentCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateOneWithoutPlayersInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPlayersInput
}

input UserCreateOneWithoutTournamentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTournamentsInput
}

input UserCreateWithoutPlayersInput {
  authProvider: AuthProviderCreateOneWithoutUserInput
  contacts: ContactCreateManyWithoutUserInput
  createdAt: DateTime
  credits: Int
  id: String
  name: String
  tournaments: TournamentCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutTournamentsInput {
  authProvider: AuthProviderCreateOneWithoutUserInput
  contacts: ContactCreateManyWithoutUserInput
  createdAt: DateTime
  credits: Int
  id: String
  name: String
  players: PlayerCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateInput {
  authProvider: AuthProviderUpdateOneWithoutUserInput
  contacts: ContactUpdateManyWithoutUserInput
  createdAt: DateTime
  credits: Int
  id: String
  name: String
  players: PlayerUpdateManyWithoutUserInput
  tournaments: TournamentUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateManyMutationInput {
  createdAt: DateTime
  credits: Int
  id: String
  name: String
  updatedAt: DateTime
}

input UserUpdateOneRequiredWithoutPlayersInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPlayersInput
  update: UserUpdateWithoutPlayersDataInput
  upsert: UserUpsertWithoutPlayersInput
}

input UserUpdateOneWithoutTournamentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTournamentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutTournamentsDataInput
  upsert: UserUpsertWithoutTournamentsInput
}

input UserUpdateWithoutPlayersDataInput {
  authProvider: AuthProviderUpdateOneWithoutUserInput
  contacts: ContactUpdateManyWithoutUserInput
  createdAt: DateTime
  credits: Int
  id: String
  name: String
  tournaments: TournamentUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateWithoutTournamentsDataInput {
  authProvider: AuthProviderUpdateOneWithoutUserInput
  contacts: ContactUpdateManyWithoutUserInput
  createdAt: DateTime
  credits: Int
  id: String
  name: String
  players: PlayerUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpsertWithoutPlayersInput {
  create: UserCreateWithoutPlayersInput!
  update: UserUpdateWithoutPlayersDataInput!
}

input UserUpsertWithoutTournamentsInput {
  create: UserCreateWithoutTournamentsInput!
  update: UserUpdateWithoutTournamentsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  authProvider: AuthProviderWhereInput
  contacts: ContactFilter
  createdAt: DateTimeFilter
  credits: NullableIntFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  players: PlayerFilter
  tournaments: TournamentFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  id: String
}

scalar UUID

input UUIDFilter {
  contains: UUID
  endsWith: UUID
  equals: UUID
  gt: UUID
  gte: UUID
  in: [UUID!]
  lt: UUID
  lte: UUID
  not: UUID
  notIn: [UUID!]
  startsWith: UUID
}
